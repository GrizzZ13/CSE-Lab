#include <iostream>
#include <fstream>
#include <sstream>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <dirent.h>

#include <mutex>
#include <string>
#include <vector>
#include <map>

#include "rpc.h"
#include "mr_protocol.h"

#define DEBUG

using namespace std;

struct KeyVal {
    string key;
    string val;
};

bool isLetter(const char &a) {
    if(a>='a'&&a<='z'){
        return true;
    }
    if(a>='A'&&a<='Z'){
        return true;
    }
    return false;
}

//
// The map function is called once for each file of input. The first
// argument is the name of the input file, and the second is the
// file's complete contents. You should ignore the input file name,
// and look only at the contents argument. The return value is a slice
// of key/value pairs.
//
vector<KeyVal> Map(const string &filename, const string &content)
{
	// Copy your code from mr_sequential.cc here.
	map<string, size_t> wordCount;
    vector<KeyVal> ret;
    size_t inputLength = content.length();
    size_t pos = 0;
    size_t len = 0;
    bool word = false;
    string key;
    for (size_t i = 0; i < inputLength; i++){
        if(isLetter(content[i])){
            if(word==false){
                word=true;
                pos = i;
            }
            len++;
        }
        else{
            if(len>0){
                key = content.substr(pos, len);
                wordCount[key]++;
            }
            word = false;
            len = 0;
        }
    }
    for(auto &w : wordCount){
        KeyVal kv;
        kv.key = w.first;
        kv.val = to_string(w.second);
        ret.push_back(kv);
    }
    return ret;
}

//
// The reduce function is called once for each key generated by the
// map tasks, with a list of all the values created for that key by
// any map task.
//
string Reduce(const string &key, const vector < string > &values)
{
    // Copy your code from mr_sequential.cc here.
	int count = 0;
    uint32_t size = values.size();
    for(int i = 0;i<size;++i){
        int temp = std::atoi((values[i]).c_str());
        count += temp;
    }
    return to_string(count);
}


typedef vector<KeyVal> (*MAPF)(const string &key, const string &value);
typedef string (*REDUCEF)(const string &key, const vector<string> &values);

class Worker {
public:
	Worker(const string &dst, const string &dir, MAPF mf, REDUCEF rf);

	void doWork();

private:
	void doMap(int index, const string &filename);
	void doReduce(int index);
	void doSubmit(mr_tasktype taskType, int index);
	int hash(const string &filename);

	mutex mtx;
	int id;

	rpcc *cl;
	std::string basedir;
	MAPF mapf;
	REDUCEF reducef;
};


Worker::Worker(const string &dst, const string &dir, MAPF mf, REDUCEF rf)
{
	this->basedir = dir;
	this->mapf = mf;
	this->reducef = rf;
	#ifdef DEBUG
	cout << "basedir: " << this->basedir << endl;
	#endif

	sockaddr_in dstsock;
	make_sockaddr(dst.c_str(), &dstsock);
	this->cl = new rpcc(dstsock);
	if (this->cl->bind() < 0) {
		printf("mr worker: call bind error\n");
	}
}

int Worker::hash(const string &filename){
	int origin = filename.size() + (int)(filename[0]) +(int)(filename[filename.size()-1]);
	return (origin % 4);
}

void Worker::doMap(int index, const string &filename)
{
	// Lab2: Your code goes here.
	#ifdef DEBUG
	cout << "basedir: " << basedir << " , filename: " << filename << endl;
	#endif
	string content;
	getline(ifstream(filename), content, '\0');
	vector<KeyVal> pairs = mapf(filename, content);
	ofstream out0(basedir+"/mr-"+to_string(index)+"-0");
    ofstream out1(basedir+"/mr-"+to_string(index)+"-1");
    ofstream out2(basedir+"/mr-"+to_string(index)+"-2");
    ofstream out3(basedir+"/mr-"+to_string(index)+"-3");
	for(auto &pair : pairs){
		switch(hash(pair.key)){
			case 0:
				out0 << pair.key << '\t' << pair.val << endl;
                break;
            case 1:
				out1 << pair.key << '\t' << pair.val << endl;
                break;
            case 2:
				out2 << pair.key << '\t' << pair.val << endl;
                break;
            case 3:
				out3 << pair.key << '\t' << pair.val << endl;
                break;
            default:
                break;
		}
	}
	out0.close();
    out1.close();
    out2.close();
    out3.close();
	doSubmit(mr_tasktype::MAP, index);
}

void Worker::doReduce(int index)
{
	// Lab2: Your code goes here.
	int map_index = 0;
	map<string, uint32_t> wordCount;
	string buf;
	while(1){
		buf = "";
		string key;
		uint32_t val;
		ifstream in(basedir+"/mr-"+to_string(map_index)+"-"+to_string(index));
		map_index++;
		if(in.is_open()){
			#ifdef DEBUG
			cout << "basedir: " << basedir << " , index: " << index << endl;
			#endif
			while(getline(in, buf)){
				stringstream ss;
				ss << buf;
				ss >> key >> val;
				wordCount[key] += val;
			}
			in.close();
		}
		else{
			break;
		}
	}
	ofstream out(basedir+"/mr-out"+to_string(index));
	for(auto &entry : wordCount){
		out << entry.first << ' ' << entry.second << endl;
	}
	out.close();
	doSubmit(mr_tasktype::REDUCE, index);
}

void Worker::doSubmit(mr_tasktype taskType, int index)
{
	bool b;
	mr_protocol::status ret = this->cl->call(mr_protocol::submittask, taskType, index, b);
	if (ret != mr_protocol::OK) {
		fprintf(stderr, "submit task failed\n");
		exit(-1);
	}
}

void Worker::doWork()
{
	#ifdef DEBUG
	cout << "work" << endl;
	#endif
	for (;;) {

		//
		// Lab2: Your code goes here.
		// Hints: send asktask RPC call to coordinator
		// if mr_tasktype::MAP, then doMap and doSubmit
		// if mr_tasktype::REDUCE, then doReduce and doSubmit
		// if mr_tasktype::NONE, meaning currently no work is needed, then sleep
		//
		mr_protocol::AskTaskResponse response;
		mr_protocol::status ret = this->cl->call(mr_protocol::asktask, 1, response);
		#ifdef DEBUG
		cout << "response: " << response.taskType << endl; 
		#endif
		if(response.taskType==mr_tasktype::MAP){
			doMap(response.index, response.filename);
		}
		else if(response.taskType==mr_tasktype::REDUCE){
			doReduce(response.index);
		}
		else{
			sleep(1);
		}
	}
}

int main(int argc, char **argv)
{
	if (argc != 3) {
		fprintf(stderr, "Usage: %s <coordinator_listen_port> <intermediate_file_dir> \n", argv[0]);
		exit(1);
	}

	MAPF mf = Map;
	REDUCEF rf = Reduce;
	
	Worker w(argv[1], argv[2], mf, rf);
	w.doWork();

	return 0;
}

